Започнат на	Friday, 28 January 2022, 09:37
Състояние	Завършен
Приключен на	Friday, 28 January 2022, 10:50
Изминало време	1 час 13 мин.
Точки	52,00/53,00
Оценка	490,57 от 500,00 (98%)
Въпрос 1
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

Представете си че имате произволен сортиран масив и търсите елемент 6 с двоично търсене.Кои от следните редици на сравнения с числа от масива са възможни преди да открием числото 6.




a.
17,10,3,7,6


b.
 90,15,2,3,6


c.
 13,8,9,2,6


d.
13,3,7,4,6

Въпрос 2
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

При използване на масив за реализация на maxheap, Кои от масивите биха представяли такава пирамида?




1.
25,12,16,13,10,8,14


2.
25,14,12,13,10,8,16


3.
25,12,16,13,10,8,1


4.
25,14,16,13,10,8,12

Въпрос 3
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Колко са ребрата на ненасочен граф с n възела ако е пълен?


a.
(n*(n+1))/2


b.
n*(n-1)


c.
2n


d.
(n*(n-1))/2

Въпрос 4
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

 Каква е сложността на фрагмента код?

for(int i = 0 ; i < N ;i++ )

    for(int j = N-i;j>=1; j=j/3)

         cout << (i+j);




a.
O(log(n)^2)


b.
O(log(n))


c.
Друга сложност


d.
O(2^n)


e.
O(log(n)*n)

Въпрос 5
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете всички верни твърдения:


a.
Бързото сортиране(quick sort) е със сложност в най-лошият случай О(nlog(n))

b.
Сортирането със сливане(merge sort) е със сложност в най-лошият случай О(n^2)


c.
Сортирането с вмъкване е със сложност в най-лошият случай О(n^2)


d.
Сортирането с броене(counting sort) е със сложност в най-лошият случай О(nlog(n))

Въпрос 6
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете верните твърдения:


a.
 задачата за търговският пътник е NP complete проблем


b.
алгоритмите на Прим и Крускал се ползват за намиране на минимален път между два възела в графа.


c.
Намиране на Ойлеров път в граф е NP complete проблем


d.
Търсенето в ширина намира най-кратък път в непретеглен граф.

Въпрос 7
Неправилен отговор
0,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
При алгоритъм на Prim започваме  да строим дърво от


1.
от най-лекото ребро


2.
от произволен връх


3.
от най-големият връх


4.
от най-тежкото ребро

Въпрос 8
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете всички верни твърдения:


1.
Сортирането с броене(counting sort) е със сложност в най-лошият случай О(nlog(n))


2.
Сортирането със сливане(merge sort) е със сложност в най-лошият случай О(nlog(n))


3.
Бързото сортиране(quick sort) е със сложност в най-лошият случай О(n^2)


4.
Сортирането по метода на мехурчето е със сложност в най-лошият случай О(nlog(n))


Въпрос 9
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
За DFS се използва:


1.
Queue


2.
AVL


3.
Stack


4.
Нито едно

Въпрос 10
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Каква е сложността на задачата да се намери сумата на ребрата в графа, ако графа ни е представен с матрица на съседство.


1.
O(E^2)


2.
O(V)


3.
O(V^2)


4.
O(E)

Въпрос 11
Правилен отговор
1,00 от максимално 1,00 точки
ОтбелязанПремахване на отбелязването
Текст на въпроса
Ако V са броя на възлите а Е броя на ребрата в граф. Броя на свързаните компоненти в намираме за?


1.
O(E)


2.
O(V)


3.
O(E+V)


4.
O(E*V)

Въпрос 12
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

Даден е масивът -4, -2, 0, 4, 5, 7, 14, 30, 29, 66, 71. Търсим числото -2. Колко най-малко пъти може да бъде извикан binarySearch()?




1.
3


2.
4


3.
1


4.
5


5.
2

Въпрос 13
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Каква е сложността на задачата да се намери сумата на ребрата в графа, ако графа ни е представен с матрица на съседство.


a.
O(V^2)


b.
O(V)


c.
O(E)


d.
O(E^2)

Въпрос 14
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Каква е гарантираната сложност на добавяне на елемент в Hash map?


1.
O(1)


2.
O(logN)


3.
O(N)

Въпрос 15
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

С каква сложност е най-оптималният сортиращ алгоритъм, който работи с double числа?



a.
O(N*Log N)


b.
O(N)


c.
O(N) време и O(N) памет


d.
O(N^2)

Въпрос 16
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Ако две числа са различни, то и техните хешове ще са различни?


1.
да


2.
не

Въпрос 17
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Изберете алгоритъма с най-голяма асимптотична сложност


1.
Сортиране с броене


2.
Линейно търсене


3.
Merge Sort

Въпрос 18
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете всички твърдения, които НЕ са верни:


a.
При опашката, първият елемент който влиза в структурата е първият който излиза.


b.
Ако реализираме стек с масив вместо със свързан списък то добавянето на елемент в стека става със сложност във средният случай О(n)


c.
Елемент в Свързан Списък може да бъде достъпен по индекс за O(1) време


d.
При масива първият вкаран елемент е и първият изкаран.

Въпрос 19
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Кои са предимствата на граф с списък на съседство пред матрица на съседство.


1.
Добавяне на връх е по-лесно


2.
Спестява се място за sparce графи


3.
Спестява се място за пълни графи


4.
DFS и BFS са с по-добро време

Въпрос 20
Правилен отговор
1,00 от максимално 1,00 точки
ОтбелязанПремахване на отбелязването
Текст на въпроса

 Кой алгоритъм можем да използваме за намиране на най-къс път в граф с отрицателни тегла по ребрата?




1.
Kruskal


2.
Floyd-Warshall


3.
Dijkstra


4.
Bellman-Ford

Въпрос 21
Правилен отговор
1,00 от максимално 1,00 точки
ОтбелязанПремахване на отбелязването
Текст на въпроса
Изберете от списъка по-долу всички алгоритми за сортиране не използват допълнителна памет?


1.
Counting Sort


2.

Heap sort




3.
Merge Sort


4.
Radix sort

Въпрос 22
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Коя от следните Hash функции може да се използва за Hash map


a.
MD5


b.
((a*x+b) mod p) mod n


c.
SHA-256


d.
MD4

Въпрос 23
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете верните твърдения за двойно свързан списък:


1.
сложност на търсене на елемент в списък О(n)


2.
сложност на изтриване на елемент от края на свързан списък О(1)


3.
сложност на премахване на елемент от позиция к в списъка О(1)


4.
сложност на добавяне на елемент в края на свързан списък О(1)

Въпрос 24
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
За кой от изброените проблеми, оптималният за решаване алгоритъм е с най-голяма асимптотична сложност


1.
Намиране на минимално покриващо дърво в граф


2.
Намиране на най-късите пътища в граф от всеки връх до всеки друг връх


3.
Сортиране на масив във милиард елемента


4.
Намиране на Хамилтонов цикъл в граф

Въпрос 25
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете верните твърдения:


a.
Сложността за изтриване на елемент в двоично дърво за търсене в най-лошият случай е О(logN)


b.
 Сложността за търсене на елемент в двоично дърво за търсене в най-лошият случай е О(N)


c.
Сложността за добавяне на елемент в двоично дърво за търсене в най-лошият случай е О(logN)

Въпрос 26
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Каква е сложността на Merge Sort в най-лошия случай?


1.
O(N*Log N)


2.
O(N^2)


3.
O(N!)


4.
O(N)

Въпрос 27
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Каква е сложността на следния фрагмент от код:


for(int i=1;i<=n;i*=2)

     k = k + 2;

a.
Друга сложност


b.
O(n^2)


c.
O(n)


d.
O(1)


e.
O(log(n))


f.
O(n*log(n))

Въпрос 28
Правилен отговор
1,00 от максимално 1,00 точки
ОтбелязанПремахване на отбелязването
Текст на въпроса

С хеш функция h(key)=key mod 7, използвайки linear probing са добавени в хешмап числата: 44, 45, 79, 55, 91, 18, 77  на коя позиция би била 18 (7 места).




1.
1


2.
2


3.
4


4.
3


5.
5


6.
6

Въпрос 29
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

Имаме указател към Node от едносвързан списък. Каква е сложността на добавяне на елемент след него?



1.
О(N^2)


2.

О(log N)



3.
О(N)


4.
О(1)

Въпрос 30
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Колко върха има MST, намерено чрез алгоритъм Крускал?


1.
E


2.
V


3.
V/2


4.
E/2

Въпрос 31
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Алгоритъм е?


1.
Крайна последователност от стъпки, решаващи някакъв проблем


2.
Математическа функция


3.
Безкрайна последователност от стъпки


4.
Програма, написана на някой програмен език

Въпрос 32
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете всички верни твърдения:


a.
двоичното търсене е еднакво ефективно за сортиран масив и сортиран свързан списък


b.
линейното търсене е по-добър избор от двоичното търсене за търсене в несортиран масив


c.
двоичното търсене може да се използва само за сортиран масив


d.
двоичното търсене има сложност О(nlog(n)) върху сортиран маси

Въпрос 33
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Кое от следните твърдения е вярно за всички видове Двоично Дърво на Търсене


a.
Нито едно от изброените


b.
 Лявото дете винаги е по-малко от родителя си


c.
Лявото и Дясното под-дървета винаги трябва да са Двоично Дърво на Търсене


d.
Всички двоични дървета за търсене са балансирани

Въпрос 34
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Коя от следните структури НЕ е двоично дърво?


1.
AVL


2.
Всички са двоични дървета


3.
Red-black Tree


4.
Heap


5.
BST

Въпрос 35
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

Ако се създаде двоично дърво за търсене(BST) и към него се добавят числата 71, 65, 84, 69, 66, 83, кой елемент ще е на най-ниско ниво?




1.
69


2.
83


3.
Има няколко елемента на най-ниско ниво


4.
65


5.
66

Въпрос 36
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Ако използваме алгоритъмът на Kruskal, кои ребра ще участват в минималното покриващо дърво?




1.
a,b,d,e


2.
a,b,c,d


3.
a,b,c,e

4.
a,c,d,e

Въпрос 37
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
В максимална пирамида(min heap), елемента с най-голям ключ е винаги в какъв възел?


a.
Корена


b.
Първият възел в дясното поддърво


c.
Първият възел в лявото поддърво


d.
Листо

Въпрос 38
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Изберете верните твърдения:


1.
Алгоритъма на Дейкстра не работи за граф с отрицателни тегла по ребрата


2.
Алгоритъма на Дейкстра е със сложност O(E^2) понеже обхожда всички ребра два пъти


3.
Алгоритъма на Дейкстра може да намери минимално покриващо дърво в граф.


4.
Алгоритъма на Дейкстра използва търсене в дълбочина

Въпрос 39
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

Кои от следните твърдения за алгоритъма на Dijkstra са верни:




1.
Намира минималните пътища от един начален връх до всички останали


2.
Дава верен резултат ако всички ребра са с неотрицателни тежести.


3.
 Дава верен резултат дори ако има ребра с отрицателни тежести


4.
Това е оптималния по време алгоритъм за намиране на минимални пътища в непретеглен граф.

Въпрос 40
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Каква е сложността на следния фрагмент от код:


for(int i=1;i<=n;i++)

     for(int j=n;j<=1;j++)

             k = k + 1;

a.
Друга сложност


b.
O(n^log(n))


c.
O(1)


d.
O(n!)


e.
O(n^2)

Въпрос 41
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса

Каква е сложността на фрагмента код?

for(int i = n; i < 1 ; i/=2)

    k = k+4




a.
O(N)


b.
O(log(n))


c.
друга сложност


d.
O(N^2)


e.
O(2^n)

Въпрос 42
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Как се наричат елементите, които нямат наследници в двоично дърво?


1.
Листа


2.
Самотни


3.
Деца


4.
Корени

Въпрос 43
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Сложността по памет при списък на съседите за ненасочен и непретеглен граф с множество от върхове V и множество на ребра E е:


a.
O(V*V)


b.
O(V)


c.
O(E+V)


d.
O(E)

Въпрос 44
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Алгоритъм на Prim е по-добър от Kruskal за spare граф


1.
Да


2.
Не

Въпрос 45
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Кои от структурите НЕ е дърво?


1.
HashMap


2.
Red-black Tree


3.
Graph


4.
AVL


5.
Heap

Въпрос 46
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете верните твърдения за двойно свързан списък:


a.
сложност на изтриване на елемент от края на свързан списък О(n)


b.
сложност на търсене на елемент в списък О(n)


c.
 сложност на добавяне на елемент в края на свързан списък О(1)


d.
сложност на премахване на вече намерен елемент О(1)

Въпрос 47
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Отбележете всички редиците със сложности за изпълнение сортирани в нарастващ ред?


a.
О(1), О(log(n)), O(n), O(2^n), O(n^2)


b.
О(1), О(log(n)), О(log(n)^2), O(n*log(n)), O(n^2), O(n^3), O(2^n)


c.
O(2^5), O(log(n)), O(n)


d.
O(log(n)^3),O(n), O(n*log(n))

Въпрос 48
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
След първа итерация за сортиране възходящо с Quick Sort, масива изглежда така: 2 5 1 7 9 12 11 14. Отбележете елементите които биха могли да са разделящият елемент(pivot)?


1.
9


2.
4


3.
12


4.
1


5.
7

Въпрос 49
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Кое от следните представяния на граф ще доведе до оптимална сложност по време при имплементиране на обхождане в ширина?


1.
Матрица на съседство


2.
Списък на ребрата


3.
Списък на инцидентност


4.
Списък на съседство

Въпрос 50
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
На изображението е показано валидно двоично дърво за търсене




1.
ДА


2.
Не

Въпрос 51
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Всички знаем, че в сортиран възходящо масив можем да търсим с Binary search. Можем ли да приложим Binary search ако масивът е сортиран низходящо?


a.
Не


b.
Да

Въпрос 52
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
Каква е сложността на следния фрагмент от код?


x = x + 1;

for(int i=1;i<=N;i++)

     m = m + 2;

for(int i=1;i<=N;i++)

     for(int j=N;j>=i;j–)

         k = k + 1;

a.
O(n^3)


b.
О(log(n)*n^2)


c.
O(n^2)


d.
Друга сложност.


e.
O(n*log(n))

Въпрос 53
Правилен отговор
1,00 от максимално 1,00 точки
НеотбелязанОтбелязване на въпроса
Текст на въпроса
BFS е еквивалентно на коя стратегия за търсене в Двоични дървета?


a.
Level-order traversal


b.
Pre-order traversal


c.
In-order traversal


d.
Post-order traversal
